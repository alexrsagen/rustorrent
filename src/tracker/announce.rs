use crate::bencode;
use crate::error::Error;
use crate::peer::PeerInfo;

use std::net::IpAddr;
use std::str::FromStr;
use std::convert::{TryFrom, TryInto, AsRef};
use std::time::Duration;

#[derive(Debug, Default, PartialEq, Eq, Clone)]
pub struct AnnounceRequest {
    /// urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file. Note that the value will be a bencoded dictionary, given the definition of the info key above.
    pub info_hash: Option<[u8; 20]>,
    /// urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup. This is allowed to be any value, and may be binary data. There are currently no guidelines for generating this peer ID. However, one may rightly presume that it must at least be unique for your local machine, thus should probably incorporate things like process ID and perhaps a timestamp recorded at startup. See peer_id below for common client encodings of this field.
    pub peer_id: Option<[u8; 20]>,
    /// The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889. Clients may choose to give up if it cannot establish a port within this range.
    pub port: Option<u16>,
    /// The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII. While not explicitly stated in the official specification, the concensus is that this should be the total number of bytes uploaded.
    pub uploaded: Option<usize>,
    /// The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII. While not explicitly stated in the official specification, the consensus is that this should be the total number of bytes downloaded.
    pub downloaded: Option<usize>,
    /// The number of bytes this client still has to download in base ten ASCII. Clarification: The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
    pub left: Option<usize>,
    /// Setting this to 1 indicates that the client accepts a compact response. The peers list is replaced by a peers string with 6 bytes per peer. The first four bytes are the host (in network byte order), the last two bytes are the port (again in network byte order). It should be noted that some trackers only support compact responses (for saving bandwidth) and either refuse requests without "compact=1" or simply send a compact response unless the request contains "compact=0" (in which case they will refuse the request.)
    pub compact: bool,
    /// Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
    pub no_peer_id: bool,
    /// If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified). If not specified, then this request is one performed at regular intervals.
    /// Some(String::from("started")): The first request to the tracker must include the event key with this value.
    /// Some(String::from("stopped")): Must be sent to the tracker if the client is shutting down gracefully.
    /// Some(String::from("completed")): Must be sent to the tracker when the download completes. However, must not be sent if the download was already 100% complete when the client started. Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
    pub event: Option<String>,
    /// Optional. The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 address. Notes: In general this parameter is not necessary as the address of the client can be determined from the IP address from which the HTTP request came. The parameter is only needed in the case where the IP address that the request came in on is not the IP address of the client. This happens if the client is communicating to the tracker through a proxy (or a transparent web proxy/cache.) It also is necessary when both the client and the tracker are on the same local side of a NAT gateway. The reason for this is that otherwise the tracker would give out the internal (RFC1918) address of the client, which is not routable. Therefore the client must explicitly state its (external, routable) IP address to be given out to external peers. Various trackers treat this parameter differently. Some only honor it only if the IP address that the request came in on is in RFC1918 space. Others honor it unconditionally, while others ignore it completely. In case of IPv6 address (e.g.: 2001:db8:1:2::100) it indicates only that client can communicate via IPv6.
    pub ip: Option<IpAddr>,
    /// Optional. Number of peers that the client would like to receive from the tracker. This value is permitted to be zero. If omitted, typically defaults to 50 peers.
    pub num_want: Option<usize>,
    /// Optional. An additional identification that is not shared with any other peers. It is intended to allow a client to prove their identity should their IP address change.
    pub key: Option<String>,
    /// Optional. If a previous announce contained a tracker id, it should be set here.
    pub tracker_id: Option<String>,
}

fn boolish(s: &str) -> bool {
    match s {
        "1" => true,
        "on" => true,
        "yes" => true,
        "true" => true,
        _ => false,
    }
}

impl From<&mut url::form_urlencoded::Parse<'_>> for AnnounceRequest {
    fn from(input: &mut url::form_urlencoded::Parse<'_>) -> AnnounceRequest {
        let mut output = AnnounceRequest { ..Default::default() };
        for (k, v) in input {
            match k.as_ref() {
                "info_hash" => {
                    if v.as_bytes().len() == 20 {
                        output.info_hash = v.as_bytes().try_into().ok();
                    }
                },
                "peer_id" => {
                    if v.as_bytes().len() == 20 {
                        output.peer_id = v.as_bytes().try_into().ok();
                    }
                },
                "port" => {
                    output.port = u16::from_str(v.as_ref()).ok();
                },
                "uploaded" => {
                    output.uploaded = usize::from_str(v.as_ref()).ok();
                },
                "downloaded" => {
                    output.downloaded = usize::from_str(v.as_ref()).ok();
                },
                "left" => {
                    output.left = usize::from_str(v.as_ref()).ok();
                },
                "compact" => {
                    output.compact = boolish(v.as_ref());
                },
                "no_peer_id" => {
                    output.no_peer_id = boolish(v.as_ref());
                },
                "event" => {
                    if !v.as_ref().is_empty() {
                        output.event = Some(v.to_string());
                    }
                },
                "ip" => {
                    output.ip = IpAddr::from_str(v.as_ref()).ok();
                },
                "numwant" => {
                    output.num_want = usize::from_str(v.as_ref()).ok();
                },
                "key" => {
                    if !v.as_ref().is_empty() {
                        output.key = Some(v.to_string());
                    }
                },
                "trackerid" => {
                    if !v.as_ref().is_empty() {
                        output.tracker_id = Some(v.to_string());
                    }
                },
                _ => {},
            }
        }
        output
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Announce {
    pub warning_message: Option<String>,
    pub interval: Duration,
    pub min_interval: Option<Duration>,
    pub tracker_id: Option<String>,
    pub complete: i64,   // seeders
    pub incomplete: i64, // leechers
    pub peers: Vec<PeerInfo>,
}

impl TryFrom<bencode::Dict> for Announce {
    type Error = Error;
    fn try_from(mut dict: bencode::Dict) -> Result<Self, Self::Error> {
        let mut warning_message: Option<String> = None;
        let interval: Duration;
        let mut min_interval: Option<Duration> = None;
        let mut tracker_id: Option<String> = None;
        let complete: i64;
        let incomplete: i64;
        let peers: Vec<PeerInfo>;

        if let Some(bencode::Value::Bytes(warning_message_v)) = dict.remove("warning message") {
            if let Ok(warning_message_str) = String::from_utf8(warning_message_v) {
                warning_message = Some(warning_message_str);
            }
        }
        if let Some(bencode::Value::Int(interval_v)) = dict.remove("interval") {
            interval = Duration::from_secs(interval_v as u64);
        } else {
            return Err(Error::ValueTypeMissingOrInvalid("interval".into()));
        }
        if let Some(bencode::Value::Int(min_interval_v)) = dict.remove("min interval") {
            min_interval = Some(Duration::from_secs(min_interval_v as u64));
        }
        if let Some(bencode::Value::Bytes(tracker_id_v)) = dict.remove("tracker id") {
            if let Ok(tracker_id_str) = String::from_utf8(tracker_id_v) {
                tracker_id = Some(tracker_id_str);
            }
        }
        if let Some(bencode::Value::Int(complete_v)) = dict.remove("complete") {
            complete = complete_v;
        } else {
            complete = -1;
        }
        if let Some(bencode::Value::Int(incomplete_v)) = dict.remove("incomplete") {
            incomplete = incomplete_v;
        } else {
            incomplete = -1;
        }
        if let Some(peers_v) = dict.remove("peers") {
            peers = peers_v.try_into()?;
        } else {
            return Err(Error::ValueTypeMissingOrInvalid("peers".into()));
        }

        Ok(Self {
            warning_message,
            interval,
            min_interval,
            tracker_id,
            complete,
            incomplete,
            peers,
        })
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AnnounceResponse {
    Failure(String),
    Success(Announce),
}

impl TryFrom<bencode::Dict> for AnnounceResponse {
    type Error = Error;
    fn try_from(mut dict: bencode::Dict) -> Result<Self, Self::Error> {
        if let Some(bencode::Value::Bytes(failure_reason)) = dict.remove("failure reason") {
            return Ok(AnnounceResponse::Failure(String::from_utf8(
                failure_reason,
            )?));
        }
        Ok(AnnounceResponse::Success(dict.try_into()?))
    }
}

impl TryFrom<bencode::Value> for AnnounceResponse {
    type Error = Error;
    fn try_from(value: bencode::Value) -> Result<Self, Self::Error> {
        match value {
            bencode::Value::Dict(dict) => dict.try_into(),
            bencode::Value::Invalid(e) => Err(Error::Bencode(e)),
            _ => Err(Error::ValueTypeMissingOrInvalid("announce".into())),
        }
    }
}

impl TryFrom<&[u8]> for AnnounceResponse {
    type Error = Error;
    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        bencode::Value::from(value).try_into()
    }
}

impl TryFrom<Vec<u8>> for AnnounceResponse {
    type Error = Error;
    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        (&value as &[u8]).try_into()
    }
}

impl From<&AnnounceResponse> for bencode::Dict {
    fn from(value: &AnnounceResponse) -> Self {
        let mut dict = bencode::Dict::new();
        match value {
            AnnounceResponse::Failure(reason) => {
                dict.insert(
                    "failure reason".into(),
                    bencode::Value::Bytes(reason.as_bytes().to_vec()),
                );
            }
            AnnounceResponse::Success(announce) => {
                if let Some(warning_message) = &announce.warning_message {
                    dict.insert(
                        "warning message".into(),
                        bencode::Value::Bytes(warning_message.as_bytes().to_vec()),
                    );
                }
                dict.insert(
                    "interval".into(),
                    bencode::Value::Int(announce.interval.as_secs() as i64),
                );
                if let Some(min_interval) = announce.min_interval {
                    dict.insert(
                        "min interval".into(),
                        bencode::Value::Int(min_interval.as_secs() as i64),
                    );
                }
                if let Some(tracker_id) = &announce.tracker_id {
                    dict.insert(
                        "tracker id".into(),
                        bencode::Value::Bytes(tracker_id.as_bytes().to_vec()),
                    );
                }
                dict.insert("complete".into(), bencode::Value::Int(announce.complete));
                dict.insert(
                    "incomplete".into(),
                    bencode::Value::Int(announce.incomplete),
                );
                dict.insert("peers".into(), (&announce.peers).into());
            }
        };
        dict
    }
}

impl From<AnnounceResponse> for bencode::Dict {
    fn from(value: AnnounceResponse) -> Self {
        (&value).into()
    }
}

impl From<&AnnounceResponse> for bencode::Value {
    fn from(value: &AnnounceResponse) -> Self {
        bencode::Value::Dict(value.into())
    }
}

impl From<AnnounceResponse> for bencode::Value {
    fn from(value: AnnounceResponse) -> Self {
        (&value).into()
    }
}

impl From<&AnnounceResponse> for hyper::Body {
    fn from(value: &AnnounceResponse) -> Self {
        let bval: bencode::Value = value.into();
        let bytes: Vec<u8> = bval.into();
        hyper::Body::from(bytes)
    }
}

impl From<AnnounceResponse> for hyper::Body {
    fn from(value: AnnounceResponse) -> Self {
        (&value).into()
    }
}
